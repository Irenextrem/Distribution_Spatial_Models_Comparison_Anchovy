---
title: "GLM Inla"
author: "Irene Extremera Serrano"
date: "14/1/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(eval = TRUE, warning = FALSE, error = FALSE, message = FALSE, comment = " ")
```

````{r, warning=FALSE, message=FALSE, include= FALSE}
library(sp) #Tabajar con objetos de tipo espacial
library(rgdal) #Para que funcione sdmpredictors
library(carData)
library(car)
library(nlme)
library(gstat)
library(sf)
library(spData)
library(spdep)
library(lattice)
library(survival)
library(Formula)
library(ggplot2)
library(Hmisc)
library(raster) #Para poder trabajar con objetos tipo raster
library(leaflet)
library(GGally)
library(maptools)
library(corrplot)
library(rgeos)
library(maptools) #Cargar mapas
library(dismo) #Para poder trabajar con bioclim
library(sdmpredictors) #Para descargarme las variables ambientales
library(PresenceAbsence)
library(rJava)
library(randomForest)
library(INLA) #Para trabajar con INLA
library(Matrix)
library(parallel)
library(foreach)
library(dotCall64)
library(grid)
library(spam)
library(fields)
```

```{r,include=FALSE}
# Descargo el mapa del mundo
data(wrld_simpl) #Cargo el mapa del mundo

# Datos
data <- read.csv('C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera/Datos/Anchoas_Aqua.csv',TRUE,",")
data<- data[-1]

# Predictores
files<-(list.files("C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera/Predictores/bathy", full.names=T, pattern=".tif"))#change directory
predictors <- stack(files)
names(predictors) <- c("bathy","odismean","salinity","tempmean")

plot(predictors)

# Escalo los valores para que al hacer el análisis todas las variables tengan la misma escala 
predictors2 <- scale(predictors)
round(apply(values(predictors2), 2, summary), 4)

# Cargo la base de datos
sdmdata <- read.csv("C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera/Datos/sdmdata.csv")
```

# GLM INLA

```{r}
# Polígono que incluya los puntos de presencias en Atlántico Norte
xym <- as.matrix(data.frame(x=c(-8,0,0,26,26,
                                -12,-12),
                            y=c(43,43,49,55,62,
                                62,43)))
                        

p = Polygon(xym) #Paso de matriz a polígono
ps = Polygons(list(p),1) #Lo transformo en lista.
sps = SpatialPolygons(list(ps)) #Lo transformo en un polígono espacial 

par(mfrow=c(1,1))
plot(sps)
points(data$V1,data$V2)
```

```{r}
### --- Atlántico Norte & Mediterraneo --- ###
ext<-extent(-20,40,30,70) #Me quedo con las coordenadas propias del area que me interesa 

# Error in RGEOSBinTopoFunc(spgeom1, spgeom2, byid, id, drop_lower_td, unaryUnion_if_byid_false, : TopologyException: Input geom 0 is invalid: Ring Self-intersection at or near point 5.3369464899999999 61.592775340000003 at 5.3369464899999999 61.592775340000003

m_atn <- crop(wrld_simpl, ext) #Solo Atlántico Norte
plot(m_atn)
```

NO PUEDO CONTINUAR A PARTIR DE AQUÍ:

Error in RGEOSBinTopoFunc(spgeom1, spgeom2, byid, id, drop_lower_td, unaryUnion_if_byid_false, : TopologyException: Input geom 0 is invalid: Ring Self-intersection at or near point 5.3369464899999999 61.592775340000003 at 5.3369464899999999 61.592775340000003

He probado con un polígono mas complejo que se acerque mas a los datos
También he probado hacer el extent mas grende
Pero no ha funcionado y el error era el mismo

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

```{r}
# Hago un polígono que incluya la zona marítima y la costa para posteriormente extraerla
xym2<- as.matrix(data.frame(x = c(min(data$V1), max(data$V1)+5, max(data$V1)+5, min(data$V1)), 
                           y = c(30, 30, max(data$V2)+10, max(data$V2)+10)))
# xym2<- as.matrix(data.frame(x = c( min(data$V1)-10,max(data$V1)+5 , max(data$V1)+5, min(data$V1)-10), 
#                            y = c(30, 30,max(data$V1)+5,max(data$V2)+5)))

p2 = Polygon(xym2) 
ps2 = Polygons(list(p2),1) 
sps2 = SpatialPolygons(list(ps2))  

#Represento el resultado
par(mfrow=c(1,1))
plot(sps2)
points(data[,1:2], pch=20) 
```

```{r}
#Recorto con Europa
m_atn_rec<-crop(m_atn, sps) #Me interesa este trozo de mapa

plot(m_atn_rec) #Veo cómo queda
points(data[,1:2], pch=20) #Pinto las presencias

proj4string(sps)<-proj4string(m_atn_rec) # IMPORTANTE: ¿Qué está haciendo esto?

plot(m_atn_rec) #Zonas costeras recortadas
```

```{r}
### --- Selecciono el polígono que contiene los datos --- ###
coast <- gDifference(sps, m_atn_rec ) #Con esta función me va extrayendo esa parte de tierra

# Representación de las presencias y de la costa recortada
plot(coast) 
points(data[,1:2], pch=20)

### --- Dibujo los datos --- ###

# Dibujo los datos
plot(sps) #Polígono
points(sdmdata[,9:10][which(sdmdata$pb==1),], col="red", pch=20) #Presencia
points(sdmdata[,9:10][which(sdmdata$pb==0),], col="blue", pch=1) #Ausencia
legend(-35, 40, legend=c("presence", "absence"), col=c("red", "blue"), pch=20) #Leyenda
plot(m_atn_rec, add=TRUE, col="gray") #Parte de la costa recortada
#dev.off()
```

```{r}
### --- Construyo el mesh --- ###
#### Creo el dominio que voy a estudiar con la función inla.nonconvex.hull()
boundary=inla.nonconvex.hull(as.matrix(sdmdata[,9:10])) #Como boundary utilizo los datos de longitud y latitud de presencias y ausencias
mesh<-inla.mesh.2d(boundary=boundary, max.edge=c(2, 4), #Primer elemento longitud triángulo interior y segundo elemento longitud del triángulo exterior
                   cutoff=0.01,  offset=c(-0.9, -0.09)) #Cutoff es el ángulo mínimo del triángulo // # offset es el espacio externo de la figura.

# Pinto el mesh con el mapa y los datos
plot(mesh)
plot(m_atn, add=TRUE, col="gray")
plot(mesh, add=TRUE)
points(sdmdata[,9:10][which(sdmdata$pb==1),], col="red", pch=20)
points(sdmdata[,9:10][which(sdmdata$pb==0),], col="blue", pch=20)

```

```{r}
### --- Definition of the spde --- ####
spde <- inla.spde2.matern(mesh) 

### --- Matrix which link data with the mesh --- ###
A.est <- inla.spde.make.A(mesh, loc=cbind(sdmdata$x, sdmdata$y))

### --- inla.stack to stimate --- ###
stk.est<-inla.stack(data=list(y=sdmdata$pb), #Variable respuesta
                    A=list(A.est, 1), #Matriz de covarianzas
                    effects=list(spatial=1:spde$n.spde, #Los efectos que quiera
                                 data.frame(beta0=1, sdmdata[,3:8])), #meto el b0 y todas las covariables
                    tag='est')

##--- SELECCION DEL MEJOR MODELO-------------------------------------------

setwd("C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera/Rmd")
source("C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera/Rmd/Bdiclcpomodel_stack.R")


# variables <- c("bathy", "chlomean", "ppmean","odismean","salinity","tempmean", "f(spatial, model=spde)")
variables <- c("bathy", "odismean","salinity","tempmean", "f(spatial, model=spde)")


### --- Response variable --- ###
resp=sdmdata$pb

### --- Call the function --- ###
models_bin <-Bdiclcpomodel_stack(resp=resp, variables=variables, datos=inla.stack.data(stk.est), n=20,
                                family="binomial",
                                control.predictor=list(compute=TRUE, A=inla.stack.A(stk.est)),
                                control.compute = list(config=TRUE, dic=TRUE, cpo=TRUE, waic=TRUE),
                                num.threads=2,
                                control.inla=list(strategy="gaussian"),
                                verbose=FALSE)


saveRDS(models_bin, "best_model_inla.rds")

models_bin<- readRDS("best_model_inla.rds")

models_bin$Modelos lcpo[1:10,]
models_bin$Modelos waic[1:10,]
models_bin$Modelos dic[1:10,]


# Modelo
formula.1 <- y~ -1 + beta0  + bathy + odismean +tempmean + salinity+  f(spatial,model=spde)
model.est <- inla(formula.1, #Meto la fórmula
                  data=inla.stack.data(stk.est), family="binomial" , #Le introduzco la matriz de estimación y la familia a la que pertenece
                  control.compute=list(dic=TRUE,cpo=TRUE, waic=TRUE, return.marginals=TRUE), #Criterios de calidad
                  control.predictor=list(A=inla.stack.A(stk.est), compute=TRUE,
                                         quantiles=c(0.025, 0.25, 0.5, 0.75, 0.975)),
                  #control.family=list(quantile=c(0.025)),
                  #control.inla=list(strategy = "laplace"),
                  num.threads = 3,
                  verbose=T)

saveRDS(model.est, "C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera/GLM INLA/model_est.rds")
model.est<- readRDS("C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera/GLM INLA/model_est.rds")


# plot(density(model.est$cpo$cpo))
# abline(v=cpo, col="red", lwd=2)

cpo <- mean(model.est$cpo$cpo)
waic <- model.est$waic$waic
dic <- model.est$dic$dic


write.csv(coe_inla,'C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera/GLM INLA/coe_inla_GLM.csv')
coe_inla <- read.csv('C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera/GLM INLA/coe_inla_GLM.csv')
```

```{r}
#Compute probability
1-inla.pmarginal(0, model.est$marginals.fixed$beta0) #P(beta0>0) Es mas probable que beta 0 tome valores negativos
1-inla.pmarginal(0, model.est$marginals.fixed$bathy) #P(beta1>0) Hay una probabilidad muy alta de que el valor de beta 1 o coeficiente de bathy sea positivo

### --- Plot posteriors --- ###
par(mfrow=c(1,2))
plot(model.est$marginals.fixed$bathy, type="l",main="Posterior distribution of Bathy") #El valor para el coeficiente de bathy no está centrado en 0
abline(v=0, col="red", lwd=2)

plot(model.est$marginals.fixed$beta0, type="l",main="Posterior distribution of Beta 0") #El valor para el coeficiente de bathy no está centrado en 0
abline(v=0, col="red", lwd=2)

# Resumen del modelo
summary(model.est)
# Son dos hiperparámetros porque en el efecto espacial se modeliza la media y la desviación típica como
# hiperparámetros.
```

```{r}
# Plot del modelo
plot(model.est) #IMPORTANTE: No sale el plot del modelo ¿habrá otra forma de sacarlo?
```

```{r}
####################################################
##### --- Posterior distribution hyperpars --- #####
####################################################
### --- Miro si el rango es mas pequeño que el offset --- ###
spde.result = inla.spde2.result(model.est, "spatial", spde, do.transform=TRUE) #El argumento do.transform=TRUE indica que quiero las marginales
                                      
range<-inla.emarginal(function(x) x, spde.result$marginals.range.nominal[[1]]) # se calcula la media del rango del efecto espacial (el rango es la media del efecto espacial)
                                                                               # En caso de que me interesase la media de la desviación típica usaría function(x) sqrt(x) 

### --- Miro si el rango es mas pequeño que el offset --- ###
range < max(diff(range(data[,1])), diff(range(data[,2])))*0.40

#IMPORTANTE: Sale FALSE por lo que hay que revisar el mesh. El resultado me indica que la distancia a la que están correlacionadas las obervaciones supera el 40% del area

# Si el rango es un 40% del area es mejor (busco que me salga TRUE) y si no me sale tampoco me tengo que preocupar porque no es un criterio esencial.
# Es una llamada de atención y lo que habría que hacer es reconsiderar si el mesh está bien. Sobretodo prestar atención a los bordes.

# El rango es la distancia a la que dejan de estar correlacionadas las observaciones, por lo que tengo que verificar que tenga sentido el rango que tengo para mis datos.

### --- Plot --- ###
par(mfrow=c(2,2), mar=c(3,3,1,0.5)) 
plot(spde.result$marginals.range.nominal[[1]], type='l') #Media del efecto espacial
# range #Con mayor probabilidad el valor que tome el rango es de 69.810
```

```{r}
##################################################################################
### --- Interpolación de la media y la desviación típica del efecto espacial--- ##
##################################################################################

bbox(coast) #Recupera la caja delimitadora espacial de los datos espaciales
(dxy <- apply(bbox(coast),1, diff)) #IMPORTANTE: ¿Qué es lo que se está haciendo aquí?
(r <- dxy[1]/dxy[2]) #Me quedo con este rango
m<-90 #Para no darle mucha resolución y que vaya rápido
proj.grid.mat <- 
  inla.mesh.projector(mesh, #Uso esta función para plotear los datos en inla, sino puedo extraer los datos desde el gis.
                      xlim=bbox(coast)[1,], #Los límites los fijo con los datos de la costa
                      ylim=bbox(coast)[2,] ,
                      dims=c(r, 1)*m)

par(mfrow=c(1,1))
plot(coast)
points(proj.grid.mat$lattice$loc, pch=20, cex=0.5) #Punto sobre mi mapa

### --- Linpio los NAs que quedan fuera del perímetro --- ###
ov <- over(SpatialPoints(proj.grid.mat$lattice$loc, coast@proj4string),
           coast) #Valores de mar y tierra para saber donde hay NAs

### --- check grid points inside the map --- ###
i.map <- is.na(ov)
```

```{r}
### Plot the points where we will predict ###
par(mar=c(0,0,0,0))
plot(sps)
lines(coast)
points(proj.grid.mat$lattice$loc[!i.map,], col="red", cex=0.2)
points(proj.grid.mat$lattice$loc[i.map,], col="blue", cex=0.2)# En azul donde no queremos que haya efecto espacial y en la parte roja donde quiero que aparezca el efecto espacial

### --- consider only those inside map --- ###
# proj.grid.mat$lattice$loc[i.map, ] 
#En azul donde no quiero predecir y en rojo donde si quiero

### --- Project the values of the mean and sd of the spatial effect --- ###
mean.g <- inla.mesh.project(proj.grid.mat, model.est$summary.random$spatial$mean)
sd.g <- inla.mesh.project(proj.grid.mat, model.est$summary.random$spatial$sd)
quantile_0.025 <- inla.mesh.project(proj.grid.mat, model.est$summary.random$spatial$`0.025quant`)
quantile_0.975 <- inla.mesh.project(proj.grid.mat, model.est$summary.random$spatial$`0.975quant`)


sd.g[i.map] <- mean.g[i.map] <- quantile_0.025[i.map] <- quantile_0.975[i.map] <- NA 
# Le indico que esos valores no son para predecir

#pdf("spatial_effect.pdf", width=10, height = 10)
```

```{r}
### --- Spatial effect --- ###
par(mfrow=c(2,2))
par(mar=c(2,3,3,6))

# El efecto espacial se encuentra en la variabilidad intrínseca de los datos.
# Por lo que sería una forma de ver por dónde estaría mas o menos mi especie

### --- Posterior mean --- ###
plot(sps2, col="gray", main="Spatial mean") #Cómo varía el efecto espacial de presencia de la especie
image.plot(proj.grid.mat$x, 
           proj.grid.mat$y,
           mean.g, add=TRUE)
plot(m_atn_rec, add=TRUE)

### --- Posterior sd --- ###
plot(sps2, col="gray", main="Spatial sd")
image.plot(proj.grid.mat$x, 
           proj.grid.mat$y,
           sd.g, add=TRUE)
plot(m_atn_rec, add=TRUE)


### --- Posterior q0.025 --- ###
plot(sps2, col="gray", main="Spatial q0.025")
image.plot(proj.grid.mat$x, 
           proj.grid.mat$y,
           quantile_0.025, add=TRUE)
plot(m_atn_rec, add=TRUE)

### --- Posterior q0.975 --- ###
plot(sps2, col="gray", main="Spatial q0.975")
image.plot(proj.grid.mat$x, 
           proj.grid.mat$y,
           quantile_0.975, add=TRUE)
plot(m_atn_rec, add=TRUE)
#dev.off()
```

```{r}
###########################################################################
###########################################################################
######################### --- Predicción --- ##############################
###########################################################################
###########################################################################
### --- Matrix which link the mesh with coordinates to predict--- ###
A.pred <- inla.spde.make.A(mesh, loc=proj.grid.mat$lattice$loc[!i.map, ]) #Parte espacial de la matriz de predicción
#Ahora hago una matriz de predición (la de antes era de estimación) de mi variable respuesta

### --- Stack to predict --- ###
stk.pred <- inla.stack(data=list(y=NA), #Ahora 
                       A=list(A.pred, 1), 
                       effects=list(spatial=1:spde$n.spde, #Hago una lista de lo que quiero dentro del modelo
                                    data.frame(beta0 = 1, 
                                               extract(predictors2, #Extraigo desde nuestros predictores los valores de la variable ambientales de este objeto espacial rojo y azul
                                                       proj.grid.mat$lattice$loc[!i.map, ]))), #Se podría haber hecho fuera pero así también funciona
                                                       tag='pred')

stk <- inla.stack(stk.est, stk.pred) #Junto las dos matrices de estimación y predicción


#### --- modelo --- ###
model.pred <- inla(formula.1, #Repito la fórmula de antes
                   data=inla.stack.data(stk), family="binomial", #Le paso la matriz de estimación conjunta
                   control.predictor=list(A=inla.stack.A(stk), compute=TRUE, link=1), #Quiero que me devuelva la predicción en una medida de 0 a 1 cuando pongo link=1
                   control.inla=list(strategy = "simplified.laplace"), # Strategy, hay 3: simplifylaplace, laplace y gaussiana. Es la forma que tiene inla de realizar las operaciones.
                   control.mode=list(theta=model.est$mode$theta, restart=TRUE), #Moda
                   control.results=list(return.marginals.random=FALSE, #Que no me de las marginales que ya las tengo
                                        return.marginals.predictor=FALSE), # Avoid some marginals
                   num.threads = 3, #Número de núcleos
                   verbose=FALSE)
# 
# 
# 
saveRDS(model.pred, "C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera/GLM INLA/model_pred.rds")
model.pred<-readRDS("C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera/GLM INLA/model_pred.rds")
```

```{r}
####################################################
########### --- Plot predictions --- ###############
####################################################
### index for the prediction data
idx <- inla.stack.index(stk, 'pred')$data 

summary(model.pred$summary.fitted.val$mean[idx]) #Predicción de la presencia de la especie

### --- Organize probabilities into a matrix to visualize --- ###
prob.mean <- prob.sd <- prob.0.025<- prob.0.975 <- matrix(NA, proj.grid.mat$lattice$dims[1],
                                                          proj.grid.mat$lattice$dims[2])
prob.mean[!i.map] <- c(model.pred$summary.fitted.val$mean[idx])
prob.sd[!i.map] <- c(model.pred$summary.fitted.val$sd[idx])
prob.0.025[!i.map] <- c(model.pred$summary.fitted.val$`0.025quant`[idx])
prob.0.975[!i.map] <- c(model.pred$summary.fitted.val$`0.975quant`[idx])

# Si transformo model.pred$summary.fitted.val$`0.975quant`[idx]) en un raster puedo pintarlo con plot

```

```{r}
#### --- plot del efecto espacial --- ###

#pdf("predictive.pdf", width=10, height = 10)
### --- Spatial effect --- ###
# Son probabilidades de 0 a 1 de encontrar la especie. 

par(mfrow=c(2,2))
par(mar=c(2,3,3,6))

### --- posterior predictive mean --- ###
plot(sps2, col="gray", main="Predictiva mean")
image.plot(proj.grid.mat$x, 
           proj.grid.mat$y,
           prob.mean, add=TRUE, zlim=c(0,1)) #En ved de image.plot se puede usar ggplot

plot(m_atn_rec, add=TRUE)

# points(sdmdata[,9:10][which(sdmdata$pb==1),], col="red", pch=20)
# points(sdmdata[,9:10][which(sdmdata$pb==0),], col="blue", pch=20)

### --- posterior predictive sd --- ###
plot(sps2, col="gray", main="Predictiva sd")
image.plot(proj.grid.mat$x, 
           proj.grid.mat$y,
           prob.sd, add=TRUE)
plot(m_atn_rec, add=TRUE)
# points(sdmdata[,9:10][which(sdmdata$pb==1),], col="red", pch=20)
# points(sdmdata[,9:10][which(sdmdata$pb==0),], col="blue", pch=20)


### --- posterior predictive q0.025 --- ###
plot(sps2, col="gray", main="Predictiva q0.025")
image.plot(proj.grid.mat$x, 
           proj.grid.mat$y,
           prob.0.025, add=TRUE, zlim=c(0,1))
plot(m_atn_rec, add=TRUE)

### --- posterior predictive q0.975 --- ###
plot(sps2, col="gray", main="Predictiva q0.975")
image.plot(proj.grid.mat$x, 
           proj.grid.mat$y,
           prob.0.975, add=TRUE, zlim=c(0,1))
plot(m_atn_rec, add=TRUE)

#dev.off()
```

