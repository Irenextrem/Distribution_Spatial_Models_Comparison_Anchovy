---
title: "GLM Inla"
author: "Irene Extremera Serrano"
date: "14/1/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(eval = TRUE, warning = FALSE, error = FALSE, message = FALSE, comment = " ")
```

````{r, warning=FALSE, message=FALSE, include= FALSE}
library(sp) #Tabajar con objetos de tipo espacial
library(rgdal) #Para que funcione sdmpredictors
library(carData)
library(car)
library(nlme)
library(gstat)
library(sf)
library(spData)
library(spdep)
library(lattice)
library(survival)
library(Formula)
library(ggplot2)
library(Hmisc)
library(raster) #Para poder trabajar con objetos tipo raster
library(leaflet)
library(GGally)
library(GISTools) #Para guardar coast y no tener que ejecutarlo
library(maptools)
# library(GADM) #Para poder coger el mapa de Europa y cortarlo
library(corrplot)
library(rgeos)
library(maptools) #Cargar mapas
library(dismo) #Para poder trabajar con bioclim
library(sdmpredictors) #Para descargarme las variables ambientales
library(PresenceAbsence)
library(rJava)
library(randomForest)
library(INLA) #Para trabajar con INLA
library(Matrix)
library(parallel)
library(foreach)
library(dotCall64)
library(grid)
library(spam)
library(fields)
library(classInt) 
library(GADMTools)

```

```{r,include=FALSE}

data(wrld_simpl) #Cargo el mapa del mundo

# Datos

data <- read.csv('C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera/Datos/Anchoas_Aqua_atln.csv',TRUE,",")
data<- data[-1]


# Predictores

files<-(list.files("C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera/Predictores/atl/Seleccionadas", full.names=T, pattern=".tif"))
predictors <- stack(files)
names(predictors) <- c("bathy","odismean","salinity","tempmean")

# plot(predictors)

# Escalo los valores para que al hacer el análisis todas las variables tengan la misma escala 

predictors3<- scale(predictors)


# Cargo la base de datos

sdmdata <- read.csv("C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera/Datos/sdmdata_atln_modelos.csv")
sdmdata <- sdmdata[,c(-1)]


# Dibujo el mapa con los ejes mas grandes para ver si hay algún valor que está fuera de la zona que me interesa
plot(wrld_simpl, xlim= c(-10,40),ylim=c(36,75), axes=TRUE,col="light yellow")
points(sdmdata$x, sdmdata$y, col="pink", pch=20, cex=0.75)
```


### --- GLM INLA --- ###

```{r}

# Polígono que incluya los puntos de presencias en Atlántico Norte:

xym <- as.matrix(data.frame(x=c(-7,0,0,24.6,24.6,
                                -26,-26),
                            y=c(43,43,49,55,66,
                                66,42)))
                        

p = Polygon(xym) #Paso de matriz a polígono
ps = Polygons(list(p),1) #Lo transformo en lista.
sps = SpatialPolygons(list(ps)) #Lo transformo en un polígono espacial 

par(mfrow=c(1,1))
plot(sps) #Polígono
points(sdmdata[,6:7][which(sdmdata$pb==1),], col="red", pch=20) #Presencia
points(sdmdata[,6:7][which(sdmdata$pb==0),], col="blue", pch=1) #Ausencia

```

```{r,echo=FALSE}

### --- Atlántico Norte --- ###

ext<-extent(-20,40,30,70) #Me quedo con las coordenadas propias del area que me interesa 

# Paises a usar: España, Francia, Irlanda, Reino Unido, Islandia, Alemania, Dinamarca, Noruega, Suecia, Finlandia, Letonia,Estonia, Lituania, Polonia, Rusia, Luxemburgo,Portugal, Bélgica, Paises Bajos.

# ccodes() #Para sacar los códigos de cada pais.

# Todo este código es para descargar los paises por separado.

# est <-getData('GADM',country="EST",level=0,download = TRUE)
# lit <- getData('GADM',country="LTU",level=0,download = TRUE)
# polon <-getData('GADM',country="POL",level=0,download = TRUE)
# rusia <-getData('GADM',country="RUS",level=0,download = TRUE)
# luxen <- getData('GADM',country="LUX",level=0,download = TRUE)
# port<- getData('GADM',country="PRT",level=0,download = TRUE)
# belg<-getData('GADM',country="BEL",level=0,download = TRUE)
# paises_b <-getData('GADM',country="NLD",level=0,download = TRUE)


# Y todo este es para cargar los archivos descargados y así no tener que descargarlos cada vez que trabaje con ellos. 

# setwd("C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera/Rmd/Paises")
# spain <- readRDS("gadm36_ESP_0_sp.rds")
# fra <-  readRDS("gadm36_FRA_0_sp.rds")
# irlanda <-readRDS("gadm36_IRL_0_sp.rds")
# rei_uni <- readRDS("gadm36_GBR_0_sp.rds")
# islandia <- readRDS("gadm36_ISL_0_sp.rds")
# germ <- readRDS("gadm36_DEU_0_sp.rds")
# dinam <- readRDS("gadm36_DNK_0_sp.rds")
# norueg <- readRDS("gadm36_NOR_0_sp.rds")
# suecia <-readRDS("gadm36_SWE_0_sp.rds")
# finland <-readRDS("gadm36_FIN_0_sp.rds")
# let <-readRDS("gadm36_LVA_0_sp.rds")
# est <-readRDS("gadm36_EST_0_sp.rds")
# lit <- readRDS("gadm36_LTU_0_sp.rds")
# polon <-readRDS("gadm36_POL_0_sp.rds")
# rusia <-readRDS("gadm36_RUS_0_sp.rds")
# luxen <- readRDS("gadm36_LUX_0_sp.rds")
# port<- readRDS("gadm36_PRT_0_sp.rds")
# belg<-readRDS("gadm36_BEL_0_sp.rds")
# paises_b <-readRDS("gadm36_NLD_0_sp.rds")


# Si la anterior no funciona a la hora de cargar uso esta.

# spain <-readRDS("C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera/Rmd/Paises/gadm36_ESP_0_sp.rds")
# fra <-   readRDS("C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera/Rmd/Paises/gadm36_FRA_0_sp.rds")
# irlanda <- readRDS("C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera/Rmd/Paises/gadm36_IRL_0_sp.rds")
# rei_uni <- readRDS("C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera/Rmd/Paises/gadm36_GBR_0_sp.rds")
# islandia <- readRDS("C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera/Rmd/Paises/gadm36_ISL_0_sp.rds")
# germ <- readRDS("C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera/Rmd/Paises/gadm36_DEU_0_sp.rds")
# dinam <- readRDS("C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera/Rmd/Paises/gadm36_DNK_0_sp.rds")
# norueg <- readRDS("C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera/Rmd/Paises/gadm36_NOR_0_sp.rds")
# suecia <- readRDS("C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera/Rmd/Paises/gadm36_SWE_0_sp.rds")
# finland <-  readRDS("C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera/Rmd/Paises/gadm36_FIN_0_sp.rds")
# let <-readRDS("C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera/Rmd/Paises/gadm36_LVA_0_sp.rds")
# est <-readRDS("C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera/Rmd/Paises/gadm36_EST_0_sp.rds")
# lit <- readRDS("C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera/Rmd/Paises/gadm36_LTU_0_sp.rds")
# polon <-readRDS("C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera/Rmd/Paises/gadm36_POL_0_sp.rds")
# # rusia <-readRDS("RUS_adm0.rds")
# luxen <- readRDS("C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera/Rmd/Paises/gadm36_LUX_0_sp.rds")
# port<- readRDS("C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera/Rmd/Paises/gadm36_PRT_0_sp.rds")
# belg<-readRDS("C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera/Rmd/Paises/gadm36_BEL_0_sp.rds")
# paises_b <-readRDS("C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera/Rmd/Paises/gadm36_NLD_0_sp.rds")
# rusia<-readRDS("C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera/Rmd/Paises/gadm36_RUS_0_sp.rds")

```

```{r,echo=FALSE}

# Para conseguir unir los paises en un súper mapa tuve que unir los paises uno a uno. Como tardaban tanto en unirse tuve que guardar el mapa final pero sin incluir Rusia porque me daba error.
# m1<-union(spain, fra) 
# m2<-union(m1,irlanda)
# m3<-union(m2,rei_uni)
# m4<-union(m3,germ)
# m5<- union(m4,dinam)
# m6<-union(m5,norueg)
# m7<-union(m6,suecia)
# m8<-union(m7,finland)
# m9<-union(m8,let)
# m10<-union(m9,est)
# m11<-union(m10,lit)
# m12<-union(m11,polon)
# m13<-union(m12,luxen)
# m14<-union(m13,port)
# m15<-union(m14,belg)
# m16<-union(m15,paises_b)
# saveRDS(m16, "m16.rds")
# m16 <- readRDS("C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera/Rmd/m16.rds")

# Veo cómo ha quedado el resultado final.
# plot(m16)
# cat <- crop(m16, ext) #recortar zona de interés 
# plot(cat) #Zona cortada

# saveRDS(cat, "mapa_recortado.rds") #Guardo el mapa y de esa manera solo tengo que cargarlo.

# m17<-union(m16,rusia) #Este no se ejecuta porque es muy pesado y termina dando error.
# saveRDS(m17, "m17.rds")

```


```{r}

mapa <- readRDS("C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera/Rmd/mapa_recortado.rds") #Mapa final recortado
# plot(mapa)

```

```{r}

# Hago un polígono que incluya la zona marítima y la costa para posteriormente representarlo

ext<-extent(-20,40,30,70)

xym2<- as.matrix(data.frame(x = c(min(sdmdata$x)-5, max(sdmdata$x)+4, max(sdmdata$x)+4, min(sdmdata$x)-5), 
                           y = c(42, 42, max(sdmdata$y)+1, max(sdmdata$y)+1)))

p2 = Polygon(xym2) 
ps2 = Polygons(list(p2),1) 
sps2 = SpatialPolygons(list(ps2))  


#Represento el resultado

par(mfrow=c(1,1))
plot(sps2)
points(sdmdata[,6:7], pch=20)

```

```{r}

#Recorto la zona

m_atn_rec<-crop(mapa, sps) #Me interesa este trozo de mapa del polígono
# par(mfrow=c(1,2))
# plot(m_atn_rec) #Veo cómo queda
# points(data[,1:2], pch=20) #Pinto las presencias

proj4string(sps)<-proj4string(m_atn_rec) # Da unos atributos a sps que tiene m_atn_rec

plot(m_atn_rec) #Zonas costeras recortadas

```

```{r}

### --- Selecciono el polígono que contiene los datos --- ###

# coast <- gDifference(sps, m_atn_rec) #Con esta función me va extrayendo esa parte de tierra
# shapefile(x = coast, file = "C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera/GLM INLA/coast.shp", overwrite=TRUE)
coast<-readOGR("C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera/GLM INLA/coast.shp")

# Representación de las presencias y de la costa recortada

plot(coast)
points(data[,1:2], pch=20)


### --- Dibujo los datos --- ###
# 
plot(sps) #Polígono
points(sdmdata[,6:7][which(sdmdata$pb==1),], col="red", pch=20) #Presencia
points(sdmdata[,6:7][which(sdmdata$pb==0),], col="blue", pch=1) #Ausencia
legend(-35, 50, legend=c("presence", "absence"), col=c("red", "blue"), pch=20) #Leyenda
plot(m_atn_rec, add=TRUE, col="gray") #Parte de la costa recortada
#dev.off()

```

Una vez que he conseguido la zona extrayendo la costa puedo ponerme a trabajar en el mesh y a modelizar.

```{r}

### --- Construyo el mesh --- ###
#### Creo el dominio que voy a estudiar con la función inla.nonconvex.hull()

boundary<-inla.nonconvex.hull(as.matrix(sdmdata[,6:7])) #Como boundary utilizo los datos de longitud y latitud de presencias y ausencias

mesh<-inla.mesh.2d(boundary=boundary, max.edge=c(1, 3), #Primer elemento longitud triángulo interior y segundo elemento longitud del triángulo exterior
                   cutoff=0.01,  offset=c(-0.9, -0.09)) #Cutoff es el ángulo mínimo del triángulo // # offset es el espacio externo de la figura.


# Pinto el mesh con el mapa y los datos

plot(mesh)
plot(mapa, add=TRUE, col="gray")
plot(mesh, add=TRUE)
points(sdmdata[,6:7][which(sdmdata$pb==1),], col="pink", pch=20)
points(sdmdata[,6:7][which(sdmdata$pb==0),], col="black", pch=20)

```

```{r}

### --- Defino el spde --- ####

spde <- inla.spde2.matern(mesh) 


### --- Matriz que relaciona los datos con el mesh --- ###

A.est <- inla.spde.make.A(mesh, loc=cbind(sdmdata$x, sdmdata$y))


### --- inla.stack to stimate --- ###

stk.est<-inla.stack(data=list(y=sdmdata$pb), #Variable respuesta
                    A=list(A.est, 1), #Matriz de covarianzas
                    effects=list(spatial=1:spde$n.spde, #Los efectos que quiera
                                 data.frame(beta0=1, sdmdata[,2:5])), #meto el b0 y todas las covariables
                    tag='est')

##--- SELECCION DEL MEJOR MODELO-------------------------------------------

# setwd("C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera/Rmd")
# source("C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera/Rmd/Bdiclcpomodel_stack.R")


# variables <- c("bathy", "chlomean", "ppmean","odismean","salinity","tempmean", "f(spatial, model=spde)") #En caso de querer usar todas las variables
# variables <- c("bathy", "odismean","salinity","tempmean", "f(spatial, model=spde)")


### --- Response variable --- ###
resp<-sdmdata$pb

### --- Call the function --- ###
# models_bin <-Bdiclcpomodel_stack(resp=resp, variables=variables, datos=inla.stack.data(stk.est), n=20,
#                                 family="binomial",
#                                 control.predictor=list(compute=TRUE, A=inla.stack.A(stk.est)),
#                                 control.compute = list(config=TRUE, dic=TRUE, cpo=TRUE, waic=TRUE),
#                                 num.threads=3,
#                                 control.inla=list(strategy="gaussian"),
#                                 verbose=TRUE)

# saveRDS(models_bin, "best_model_inla.rds")
# 
# models_bin<- readRDS("best_model_inla.rds")

# IMPORTANTE: ME DA ERROR AL USAR ESTA FUNCIÓN PARA VER CUÁL ES EL MEJOR MODELO.


# Modelo
formula.1 <- y~ -1 + beta0  + bathy + odismean +tempmean + salinity+  f(spatial,model=spde)
model.est <- inla(formula.1, #Meto la fórmula
                  data=inla.stack.data(stk.est), family="binomial" , #Le introduzco la matriz de estimación y la familia a la que pertenece
                  control.compute=list(dic=TRUE,cpo=TRUE, waic=TRUE, return.marginals=TRUE), #Criterios de calidad
                  control.predictor=list(A=inla.stack.A(stk.est), compute=TRUE,
                                         quantiles=c(0.025, 0.25, 0.5, 0.75, 0.975)),
                  #control.family=list(quantile=c(0.025)),
                  #control.inla=list(strategy = "laplace"),
                  num.threads = 3,
                 verbose=T)

saveRDS(model.est, "C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera/GLM INLA/modelo_inla.rds")

model.est<- readRDS("C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera/GLM INLA/modelo_inla.rds")
summary(model.est)
```

Todos lo coeficientes incluyen el cero en su intervalo de credibilidad, por lo tanto mas adelante calcularé cúal es la probabilidad de que esos coeficientes tomen el valor de cero.

```{r}

##### Indicadores penalizadores de la complejidad #####

cpo <- mean(unlist(model.est$cpo)) #Valores de la ordenada predictiva condicional (cpo) y valores de la transformada integral de probabilidad (pit) (interesan valores bajos)
wai<- model.est$waic$waic #Valores del criterio de Watanabe-Akaike y el número efectivo de parámetros estimados.
po<- mean(unlist(model.est$po))
dic<-model.est$dic$dic #El criterio de información de desviación y el número efectivo de parámetros

coe_inla <- matrix(ncol=4,nrow=1,c(cpo,wai,po,dic))
colnames(coe_inla) <- c('cpo','wai','po','dic')

write.csv(coe_inla,'C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera/GLM INLA/coe_inla_GLM.csv')

coe_inla <- read.csv('C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera/GLM INLA/coe_inla_GLM.csv');coe_inla

```

```{r}

#Miro la probabilidad de que el valor del parámetro tome el valor de 0

1-inla.pmarginal(0, model.est$marginals.fixed$beta0) #P(beta0>0) Es mas probable que beta 0 tome valores negativos
1-inla.pmarginal(0, model.est$marginals.fixed$bathy) #P(bathy>0) Hay una probabilidad muy alta de que el coeficiente de bathy no tome el valor de cero y si un valor positivo
1-inla.pmarginal(0, model.est$marginals.fixed$odismean) #P(odismean>0) El valor del coeficiente probablemente sea positivo, pero hay una probabilidad de 0.34 de ser negativo
1-inla.pmarginal(0, model.est$marginals.fixed$tempmean) #P(tempmean>0) Al igual que con batimetría, la probabilidad de que el coeficiente no tome el valor de 0 es bastante alta y además tomará sobretodo valores positivos

```

```{r}

### --- Plot posteriors --- ###

par(mfrow=c(1,2))

plot(model.est$marginals.fixed$beta0, type="l",main="Posterior distribution of Beta 0") #Incluye al 0
abline(v=0, col="red", lwd=2)

plot(model.est$marginals.fixed$bathy, type="l",main="Posterior distribution of Bathy") #El valor para el coeficiente de bathy entra el cero pero con una probabilidad baja (0.3)
abline(v=0, col="red", lwd=2)

plot(model.est$marginals.fixed$odismean, type="l",main="Posterior distribution of Odismean") #El coeficiente de odismean está centrado en 0
abline(v=0, col="red", lwd=2)

plot(model.est$marginals.fixed$tempmean, type="l",main="Posterior distribution of Tempmean") #La distribución de tempmean incluye al cero
abline(v=0, col="red", lwd=2)

plot(model.est$marginals.fixed$salinity, type="l",main="Posterior distribution of Salinity") #Está casi centrado en 0 el coeficiente de salinidad
abline(v=0, col="red", lwd=2)

```

En las gráficas anteriores se ve representado lo comentado anteriormente en el cálculo de la probabilidad de que los coeficientes tomasen valores superiores a 0.

```{r}

# Plot del modelo

plot(model.est) #IMPORTANTE: No sale el plot del modelo ¿habrá otra forma de sacarlo?

```

```{r}

####################################################
##### --- Posterior distribution hyperpars --- #####
####################################################
### --- Miro si el rango es mas pequeño que el offset --- ###

spde.result = inla.spde2.result(model.est, "spatial", spde, do.transform=TRUE) #El argumento do.transform=TRUE indica que quiero las marginales
                                      
range<-inla.emarginal(function(x) x, spde.result$marginals.range.nominal[[1]]) # se calcula la media del rango del efecto espacial (el rango es la media del efecto espacial)
                                                                               # En caso de que me interesase la media de la desviación típica usaría function(x) sqrt(x) 


### --- Miro si el rango es mas pequeño que el offset --- ###

range < max(diff(range(sdmdata[,6])), diff(range(sdmdata[,7])))*0.40

#IMPORTANTE: Sale FALSE hay que revisar el mesh. El resultado me indica que la distancia a la que están correlacionadas las obervaciones supera el 40% del area

# Si el rango es un 40% del area es mejor (busco que me salga TRUE) y si no me sale tampoco me tengo que preocupar porque no es un criterio esencial.
# Es una llamada de atención y lo que habría que hacer es reconsiderar si el mesh está bien. Sobretodo prestar atención a los bordes.

# El rango es la distancia a la que dejan de estar correlacionadas las observaciones, por lo que tengo que verificar que tenga sentido el rango que tengo para mis datos.

### --- Plot --- ###
par(mfrow=c(2,2), mar=c(3,3,1,0.5)) 
plot(spde.result$marginals.range.nominal[[1]], type='l') #Media del efecto espacial
range #Con mayor probabilidad el valor de media que tome el rango es de 70.85

```

```{r}

##################################################################################
### --- Interpolación de la media y la desviación típica del efecto espacial--- ##
##################################################################################

bbox(coast) #Recupera la caja delimitadora espacial de los datos espaciales
(dxy <- apply(bbox(coast),1, diff)) 
(r <- dxy[1]/dxy[2]) #Me quedo con este rango
m<-40 #Si lo pongo muy grande me da error: Error: no se puede ubicar un vector de tamaño 657.3 Mb. Por lo que he puesto 40
proj.grid.mat <- 
  inla.mesh.projector(mesh, #Uso esta función para plotear los datos en inla, sino puedo extraer los datos desde el gis.
                      xlim=bbox(coast)[1,], #Los límites los fijo con los datos de la costa
                      ylim=bbox(coast)[2,] ,
                      dims=c(r, 1)*m)

par(mfrow=c(1,1))
plot(coast)
points(proj.grid.mat$lattice$loc, pch=20, cex=0.5) #Punto sobre mi mapa


### --- Linpio los NAs que quedan fuera del perímetro --- ###

ov <- over(SpatialPoints(proj.grid.mat$lattice$loc, coast@proj4string),
           coast) #Valores de mar y tierra para saber donde hay NAs


### --- check grid points inside the map --- ###

i.map <- is.na(ov)

```

```{r}

### Dibujo los puntos donde he predicho ###
par(mar=c(0,0,0,0))
plot(sps)
lines(coast)
points(proj.grid.mat$lattice$loc[!i.map,], col="red", cex=0.2)
points(proj.grid.mat$lattice$loc[i.map,], col="blue", cex=0.2) # En azul donde no queremos que haya efecto espacial y en la parte roja donde quiero que aparezca el efecto espacial

### --- Considero solo los que están dentro del mapa --- ###
# proj.grid.mat$lattice$loc[i.map, ] 
#En azul donde no quiero predecir y en rojo donde si quiero
```

```{r}

### --- Project the values of the mean and sd of the spatial effect --- ###
mean.g <- inla.mesh.project(proj.grid.mat, model.est$summary.random$spatial$mean)
sd.g <- inla.mesh.project(proj.grid.mat, model.est$summary.random$spatial$sd)
quantile_0.025 <- inla.mesh.project(proj.grid.mat, model.est$summary.random$spatial$`0.025quant`)
quantile_0.975 <- inla.mesh.project(proj.grid.mat, model.est$summary.random$spatial$`0.975quant`)

```


```{r}

sd.g[i.map] <- mean.g[i.map] <- quantile_0.025[i.map] <- quantile_0.975[i.map] <- NA  
# Le indico que esos valores no son para predecir

```

```{r}
### --- Spatial effect --- ###
par(mfrow=c(2,2))
par(mar=c(2,3,3,6))

# El efecto espacial se encuentra en la variabilidad intrínseca de los datos.
# Por lo que sería una forma de ver por dónde estaría mas o menos mi especie

### --- Posterior mean --- ###
plot(sps2, col="gray", main="Spatial mean") #Cómo varía el efecto espacial de presencia de la especie
image.plot(proj.grid.mat$x, 
           proj.grid.mat$y,
           mean.g, add=TRUE)
plot(m_atn_rec, add=TRUE)

### --- Posterior sd --- ###
plot(sps2, col="gray", main="Spatial sd")
image.plot(proj.grid.mat$x, 
           proj.grid.mat$y,
           sd.g, add=TRUE)
plot(m_atn_rec, add=TRUE)


### --- Posterior q0.025 --- ###
plot(sps2, col="gray", main="Spatial q0.025")
image.plot(proj.grid.mat$x, 
           proj.grid.mat$y,
           quantile_0.025, add=TRUE)
plot(m_atn_rec, add=TRUE)

### --- Posterior q0.975 --- ###
plot(sps2, col="gray", main="Spatial q0.975")
image.plot(proj.grid.mat$x, 
           proj.grid.mat$y,
           quantile_0.975, add=TRUE)
plot(m_atn_rec, add=TRUE) #Añade el mapa
#dev.off()
```

```{r}

###########################################################################
###########################################################################
######################### --- Predicción --- ##############################
###########################################################################
###########################################################################
### --- Matrix which link the mesh with coordinates to predict--- ###
A.pred <- inla.spde.make.A(mesh, loc=proj.grid.mat$lattice$loc[!i.map, ]) #Parte espacial de la matriz de predicción
#Ahora hago una matriz de predición (la de antes era de estimación) de mi variable respuesta

### --- Stack to predict --- ###
stk.pred <- inla.stack(data=list(y=NA), #Ahora 
                       A=list(A.pred, 1), 
                       effects=list(spatial=1:spde$n.spde, #Hago una lista de lo que quiero dentro del modelo
                                    data.frame(beta0 = 1, 
                                               extract(predictors3, #Extraigo desde nuestros predictores los valores de la variable ambientales de este objeto espacial rojo y azul
                                                       proj.grid.mat$lattice$loc[!i.map, ]))), #Se podría haber hecho fuera pero así también funciona
                                                       tag='pred')

stk <- inla.stack(stk.est, stk.pred) #Junto las dos matrices de estimación y predicción


#### --- modelo --- ###
model.pred <- inla(formula.1, #Repito la fórmula de antes
                   data=inla.stack.data(stk), family="binomial", #Le paso la matriz de estimación conjunta
                   control.predictor=list(A=inla.stack.A(stk), compute=TRUE, link=1), #Quiero que me devuelva la predicción en una medida de 0 a 1 cuando pongo link=1
                   control.inla=list(strategy = "simplified.laplace"), # Strategy, hay 3: simplifylaplace, laplace y gaussiana. Es la forma que tiene inla de realizar las operaciones.
                   control.mode=list(theta=model.est$mode$theta, restart=TRUE), #Moda
                   control.results=list(return.marginals.random=FALSE, #Que no me de las marginales que ya las tengo
                                        return.marginals.predictor=FALSE), # Avoid some marginals
                   num.threads = 3, #Número de núcleos
                   verbose=FALSE)


saveRDS(model.pred, "C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera/GLM INLA/model_pred.rds")
model.pred<-readRDS("C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera/GLM INLA/model_pred.rds")

```

```{r}

####################################################
########### --- Plot predictions --- ###############
####################################################
### index for the prediction data
idx <- inla.stack.index(stk, 'pred')$data 

summary(model.pred$summary.fitted.val$mean[idx]) #Predicción de la presencia de la especie

### --- Organize probabilities into a matrix to visualize --- ###
prob.mean <- prob.sd <- prob.0.025<- prob.0.975 <- matrix(NA, proj.grid.mat$lattice$dims[1],
                                                          proj.grid.mat$lattice$dims[2])
prob.mean[!i.map] <- c(model.pred$summary.fitted.val$mean[idx])
prob.sd[!i.map] <- c(model.pred$summary.fitted.val$sd[idx])
prob.0.025[!i.map] <- c(model.pred$summary.fitted.val$`0.025quant`[idx])
prob.0.975[!i.map] <- c(model.pred$summary.fitted.val$`0.975quant`[idx])

# Si transformo model.pred$summary.fitted.val$`0.975quant`[idx]) en un raster puedo pintarlo con plot

```

```{r}
#### --- plot del efecto espacial --- ###

#pdf("predictive.pdf", width=10, height = 10)
### --- Spatial effect --- ###
# Son probabilidades de 0 a 1 de encontrar la especie. 

par(mfrow=c(2,2))
par(mar=c(2,3,3,6))

### --- posterior predictive mean --- ###
plot(sps2, col="gray", main="Predictiva mean")
image.plot(proj.grid.mat$x, 
           proj.grid.mat$y,
           prob.mean, add=TRUE, zlim=c(0,1)) #En ved de image.plot se puede usar ggplot

plot(m_atn_rec, add=TRUE)

# points(sdmdata[,6:7][which(sdmdata$pb==1),], col="red", pch=20)
# points(sdmdata[,6:7][which(sdmdata$pb==0),], col="blue", pch=20)

### --- posterior predictive sd --- ###
plot(sps2, col="gray", main="Predictiva sd")
image.plot(proj.grid.mat$x, 
           proj.grid.mat$y,
           prob.sd, add=TRUE)
plot(m_atn_rec, add=TRUE)
# points(sdmdata[,6:7][which(sdmdata$pb==1),], col="red", pch=20)
# points(sdmdata[,6:7][which(sdmdata$pb==0),], col="blue", pch=20)


### --- posterior predictive q0.025 --- ###
plot(sps2, col="gray", main="Predictiva q0.025")
image.plot(proj.grid.mat$x, 
           proj.grid.mat$y,
           prob.0.025, add=TRUE, zlim=c(0,1))
plot(m_atn_rec, add=TRUE)

### --- posterior predictive q0.975 --- ###
plot(sps2, col="gray", main="Predictiva q0.975")
image.plot(proj.grid.mat$x, 
           proj.grid.mat$y,
           prob.0.975, add=TRUE, zlim=c(0,1))
plot(m_atn_rec, add=TRUE)

#dev.off()
```

