---
title: "GLM Inla"
author: "Irene Extremera Serrano"
date: "14/1/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(eval = TRUE, warning = FALSE, error = FALSE, message = FALSE, comment = " ")
```

````{r, warning=FALSE, message=FALSE, }
library(sp) #Tabajar con objetos de tipo espacial
library(rgdal) #Para que funcione sdmpredictors
library(carData)
library(car)
library(nlme)
library(gstat)
library(sf)
library(spData)
library(spdep)
library(lattice)
library(survival)
library(Formula)
library(ggplot2)
library(Hmisc)
library(raster) #Para poder trabajar con objetos tipo raster
library(leaflet)
library(GGally)
library(maptools)
library(corrplot)
library(rgeos)
library(maptools) #Cargar mapas
library(dismo) #Para poder trabajar con bioclim
library(sdmpredictors) #Para descargarme las variables ambientales
library(PresenceAbsence)
library(rJava)
library(randomForest)
library(INLA) #Para trabajar con INLA
library(Matrix)
library(parallel)
library(foreach)
library(dotCall64)
library(grid)
library(spam)
library(fields)
```

```{r}
# Descargo el mapa del mundo
data(wrld_simpl) #Cargo el mapa del mundo
```


```{r}
# Datos
data <- read.csv('C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera/Datos/Anchoas_Aqua.csv',TRUE,",")
data<- data[-1]
```

```{r}
# Predictores
files<-(list.files("C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera/Predictores", full.names=T, pattern=".tif"))#change directory
predictors <- stack(files)
names(predictors) <- c("bathy","chlomean","ppmean","odismean","salinity","tempmean")
```

```{r}
plot(predictors)
```

```{r}
# Escalo los valores para que al hacer el análisis todas las variables tengan la misma escala 
predictors2 <- scale(predictors)
round(apply(values(predictors2), 2, summary), 4)

# Cargo la base de datos
sdmdata <- read.csv("C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera/Datos/sdmdata.csv")
```
# GLM INLA

```{r}
# Polígono entero
xym<- as.matrix(data.frame(x = c(20,26,29,29,33,36,36,31,22,21,20,20,20,16,14,11.8,11.8,14.4,14.4,15.4,15.4,15.9,15.9,17.5,19.5,19.5,16.5,15.5,13,13,15.2,13.5,11,10,10,7,5,3.5,3.5,3,2,-0.6,-0.6,-4.5,-4.5,-5.5,-5.5,-6,-6,-8.5,-8.5,-8,-1,-1,-0.5,-0.5,-1,-1,-1.7,-3,-3,-2,-1.8,-1.6,-1.5,-2,-0.7,-0.7,0,0,0.5,0.5,1,1,2,2,4.5,4.5,6,6,5,5,8.5,8.5,9,9,8.5,8.5,8,8,7.5,7.5,10,10.5,10.5,10,10,9.5,9.5,10,10,16,16,20,21.3,21.3,24.7,24.7,21.3,20.2,23,17,17,21.5,19,19,20.5,20.5,20,20,19,19,18.5,13,11,10.5,9,9,5,4,3,1,-2,-2,-9.6,-12,-10,-9,-9.5,-10,-8.5,-8.5,-7.5,-7.5,-6.7,-6.5,-8.7,-9.6,-4,-4,-3.3,-3.3,-5,-5,-6,-6.7,-8,-8,-7,-4.7,-2,-2,1.5,-2, -3,-8,-10.8,-11,-10, -8,-6.2,-5.3,-4.5,-4.5,-3,5,10,10,20),
                           y = c(33,32,32,31,31,33,35.5,37,37,40,40,40,41,45,46,45.5,44.5,44.3,43.4,43.4,43,42.8,42.4,42.4,40,38,38,39,39,40.3,40.3,42,43,44.5,44.7,44,43.5,43.5,42.6,42.5,42,40,37,37,36.4,36.4,36,36,36.4,36.4,43,43.5,43.5,45,45,45.5,45.5,46.5,47.5,47.5,49,49,48.5,48.5,50,50.5,50.5,50,50,49.5,49.5,50,50,50.5,50.5,51,51,52,52,53.1,53.1,53.5,53.5,54,54,54.5,54.5,55.5,55.5,55,55,56.4,57.5,57.5,57,57,55.5,55.5,55,55,54,54,54.5,54.5,55.3,57,57,57.5,57.5,58,60,61.2,60.5,59.5,58,57.5,57.5,56,56,55,55,55.5,57,57,60,60,59.2,58,58,59,61,62,60.5,60,60,54.5,51,52,53,54,54,55,55,55.5,55.5,52,52,51,51,53,54,55,55,55.5,55.5,57,57,58,58,58.5,55.5,55,52.2,51,50.5,49,46,40.5,36,36,35.1,  36,36,36,35,37,37,33.5,30)))



p = Polygon(xym) #Paso de matriz a polígono
ps = Polygons(list(p),1) #Lo transformo en lista.
sps = SpatialPolygons(list(ps)) #Lo transformo en un polígono espacial 

par(mfrow=c(1,1))
plot(sps)
points(data$V1,data$V2)
```

```{r}
### --- Atlántico Norte & Mediterraneo --- ###
ext<-extent(-12,37,30,58) #Me quedo con las coordenadas propias del area que me interesa 
# IMPORTANTE: No me permite aumentar mas en latitud porque sino me da este error

# Error in RGEOSBinTopoFunc(spgeom1, spgeom2, byid, id, drop_lower_td, unaryUnion_if_byid_false, : TopologyException: Input geom 0 is invalid: Ring Self-intersection at or near point 5.3369464899999999 61.592775340000003 at 5.3369464899999999 61.592775340000003

# ¿Cómo puedo hacer que me coja hasta 62? Con esa extensión el modelo se ha realizado y no ha habido ningún problema

m_atn <- crop(wrld_simpl, ext) #Solo Mediterraneo y Atlántico Norte
plot(m_atn)
```

```{r}
# Hago un polígono que incluya la zona marítima y la costa para posteriormente extraerla
xym2<- as.matrix(data.frame(x = c(min(data$V1), max(data$V1)+2, max(data$V1)+2, min(data$V1)), 
                           y = c(30, 30, max(data$V2)+1, max(data$V2)+1)))

p2 = Polygon(xym2) 
ps2 = Polygons(list(p2),1) 
sps2 = SpatialPolygons(list(ps2))  

#Represento el resultado
par(mfrow=c(1,1))
plot(sps2)
points(data[,1:2], pch=20) 
```

```{r}
#Recorto con Europa
m_atn_rec<-crop(m_atn, sps) #Me interesa este trozo de mapa

plot(m_atn_rec) #Veo cómo queda
points(data[,1:2], pch=20) #Pinto las presencias

proj4string(sps)<-proj4string(m_atn_rec) # IMPORTANTE: ¿Qué está haciendo esto?

plot(m_atn_rec) #Zonas costeras recortadas
```

```{r}
### --- Selecciono el polígono que contiene los datos --- ###
coast <- gDifference(sps, m_atn_rec ) #Con esta función me va extrayendo esa parte de tierra

# Representación de las presencias y de la costa recortada
plot(coast) 
points(data[,1:2], pch=20)

### --- Dibujo los datos --- ###

# Dibujo los datos
plot(sps) #Polígono
points(sdmdata[,9:10][which(sdmdata$pb==1),], col="red", pch=20) #Presencia
points(sdmdata[,9:10][which(sdmdata$pb==0),], col="blue", pch=1) #Ausencia
legend(-35, 40, legend=c("presence", "absence"), col=c("red", "blue"), pch=20) #Leyenda
plot(m_atn_rec, add=TRUE, col="gray") #Parte de la costa recortada
#dev.off()
```

```{r}
### --- Construyo el mesh --- ###
#### Creo el dominio que voy a estudiar con la función inla.nonconvex.hull()
boundary=inla.nonconvex.hull(as.matrix(sdmdata[,9:10])) #Como boundary utilizo los datos de longitud y latitud de presencias y ausencias
mesh<-inla.mesh.2d(boundary=boundary, max.edge=c(2, 4), #Primer elemento longitud triángulo interior y segundo elemento longitud del triángulo exterior
                   cutoff=0.01,  offset=c(-0.9, -0.09)) #Cutoff es el ángulo mínimo del triángulo // # offset es el espacio externo de la figura.

# Pinto el mesh con el mapa y los datos
plot(mesh)
plot(m_atn, add=TRUE, col="gray")
plot(mesh, add=TRUE)
points(sdmdata[,9:10][which(sdmdata$pb==1),], col="red", pch=20)
points(sdmdata[,9:10][which(sdmdata$pb==0),], col="blue", pch=20)
```

```{r}
### --- Definition of the spde --- ####
spde <- inla.spde2.matern(mesh) 

### --- Matrix which link data with the mesh --- ###
A.est <- inla.spde.make.A(mesh, loc=cbind(sdmdata$x, sdmdata$y))

### --- inla.stack to stimate --- ###
stk.est<-inla.stack(data=list(y=sdmdata$pb), #Variable respuesta
                    A=list(A.est, 1), #Matriz de covarianzas
                    effects=list(spatial=1:spde$n.spde, #Los efectos que quiera
                                 data.frame(beta0=1, sdmdata[,3:8])), #meto el b0 y todas las covariables
                    tag='est')

# variables <- c("bathy", "chlomean", "ppmean","odismean","salinity","tempmean", "f(spatial, model=spde)")
variables <- c("bathy", "f(spatial, model=spde)")

# Modelo
formula.1 <- y~ -1 + beta0  + bathy +  f(spatial,model=spde)
model.est <- inla(formula.1, #Meto la fórmula
                  data=inla.stack.data(stk.est), family="binomial" , #Le introduzco la matriz de estimación y la familia a la que pertenece
                  control.compute=list(dic=TRUE,cpo=TRUE, waic=TRUE, return.marginals=TRUE), #Criterios de calidad
                  control.predictor=list(A=inla.stack.A(stk.est), compute=TRUE,
                                         quantiles=c(0.025, 0.25, 0.5, 0.75, 0.975)),
                  #control.family=list(quantile=c(0.025)),
                  #control.inla=list(strategy = "laplace"),
                  num.threads = 3,
                  verbose=T)

saveRDS(model.est, "C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera/GLM INLA/model_est.rds")
model.est<- readRDS("C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera/GLM INLA/model_est.rds")

# model.est$cpo
# model.est$waic$waic
# model.est$dic
```

```{r}
#Compute probability
1-inla.pmarginal(0, model.est$marginals.fixed$beta0) #P(beta0>0) Es mas probable que beta 0 tome valores negativos
1-inla.pmarginal(0, model.est$marginals.fixed$bathy) #P(beta1>0) Hay una probabilidad muy alta de que el valor de beta 1 o coeficiente de bathy sea positivo

### --- Plot posteriors --- ###
par(mfrow=c(1,2))
plot(model.est$marginals.fixed$bathy, type="l",main="Posterior distribution of Bathy") #El valor para el coeficiente de bathy no está centrado en 0
abline(v=0, col="red", lwd=2)

plot(model.est$marginals.fixed$beta0, type="l",main="Posterior distribution of Beta 0") #El valor para el coeficiente de bathy no está centrado en 0
abline(v=0, col="red", lwd=2)

# Resumen del modelo
summary(model.est)
# Son dos hiperparámetros porque en el efecto espacial se modeliza la media y la desviación típica como
# hiperparámetros.
```

```{r}
# Plot del modelo
plot(model.est) #IMPORTANTE: No sale el plot del modelo ¿habrá otra forma de sacarlo?
```

```{r}
####################################################
##### --- Posterior distribution hyperpars --- #####
####################################################
### --- Miro si el rango es mas pequeño que el offset --- ###
spde.result = inla.spde2.result(model.est, "spatial", spde, do.transform=TRUE) #El argumento do.transform=TRUE indica que quiero las marginales
                                      
range<-inla.emarginal(function(x) x, spde.result$marginals.range.nominal[[1]]) # se calcula la media del rango del efecto espacial (el rango es la media del efecto espacial)
                                                                               # En caso de que me interesase la media de la desviación típica usaría function(x) sqrt(x) 

### --- Miro si el rango es mas pequeño que el offset --- ###
range < max(diff(range(data[,1])), diff(range(data[,2])))*0.40

#IMPORTANTE: Sale FALSE por lo que hay que revisar el mesh. El resultado me indica que la distancia a la que están correlacionadas las obervaciones supera el 40% del area

# Si el rango es un 40% del area es mejor (busco que me salga TRUE) y si no me sale tampoco me tengo que preocupar porque no es un criterio esencial.
# Es una llamada de atención y lo que habría que hacer es reconsiderar si el mesh está bien. Sobretodo prestar atención a los bordes.

# El rango es la distancia a la que dejan de estar correlacionadas las observaciones, por lo que tengo que verificar que tenga sentido el rango que tengo para mis datos.

### --- Plot --- ###
par(mfrow=c(2,2), mar=c(3,3,1,0.5)) 
plot(spde.result$marginals.range.nominal[[1]], type='l') #Media del efecto espacial
# range #Con mayor probabilidad el valor que tome el rango es de 69.810
```

```{r}
##################################################################################
### --- Interpolación de la media y la desviación típica del efecto espacial--- ##
##################################################################################

bbox(coast) #Recupera la caja delimitadora espacial de los datos espaciales
(dxy <- apply(bbox(coast),1, diff)) #IMPORTANTE: ¿Qué es lo que se está haciendo aquí?
(r <- dxy[1]/dxy[2]) #Me quedo con este rango
m<-40 #Para no darle mucha resolución y que vaya rápido
proj.grid.mat <- 
  inla.mesh.projector(mesh, #Uso esta función para plotear los datos en inla, sino puedo extraer los datos desde el gis.
                      xlim=bbox(coast)[1,], #Los límites los fijo con los datos de la costa
                      ylim=bbox(coast)[2,] ,
                      dims=c(r, 1)*m)

par(mfrow=c(1,1))
plot(coast)
points(proj.grid.mat$lattice$loc, pch=20, cex=0.5) #Punto sobre mi mapa

### --- Linpio los NAs que quedan fuera del perímetro --- ###
ov <- over(SpatialPoints(proj.grid.mat$lattice$loc, coast@proj4string),
           coast) #Valores de mar y tierra para saber donde hay NAs

### --- check grid points inside the map --- ###
i.map <- is.na(ov)
```

```{r}
### Plot the points where we will predict ###
par(mar=c(0,0,0,0))
plot(sps)
lines(coast)
points(proj.grid.mat$lattice$loc[!i.map,], col="red", cex=0.2)
points(proj.grid.mat$lattice$loc[i.map,], col="blue", cex=0.2)# En azul donde no queremos que haya efecto espacial y en la parte roja donde quiero que aparezca el efecto espacial

### --- consider only those inside map --- ###
# proj.grid.mat$lattice$loc[i.map, ] 
#En azul donde no quiero predecir y en rojo donde si quiero

### --- Project the values of the mean and sd of the spatial effect --- ###
mean.g <- inla.mesh.project(proj.grid.mat, model.est$summary.random$spatial$mean)
sd.g <- inla.mesh.project(proj.grid.mat, model.est$summary.random$spatial$sd)
quantile_0.025 <- inla.mesh.project(proj.grid.mat, model.est$summary.random$spatial$`0.025quant`)
quantile_0.975 <- inla.mesh.project(proj.grid.mat, model.est$summary.random$spatial$`0.975quant`)


sd.g[i.map] <- mean.g[i.map] <- quantile_0.025[i.map] <- quantile_0.975[i.map] <- NA 
# Le indico que esos valores no son para predecir

#pdf("spatial_effect.pdf", width=10, height = 10)
```

```{r}
### --- Spatial effect --- ###
par(mfrow=c(2,2))
par(mar=c(2,3,3,6))

# El efecto espacial se encuentra en la variabilidad intrínseca de los datos.
# Por lo que sería una forma de ver por dónde estaría mas o menos mi especie

### --- Posterior mean --- ###
plot(sps2, col="gray", main="Spatial mean") #Cómo varía el efecto espacial de presencia de la especie
image.plot(proj.grid.mat$x, 
           proj.grid.mat$y,
           mean.g, add=TRUE)
plot(m_atn_rec, add=TRUE)

### --- Posterior sd --- ###
plot(sps2, col="gray", main="Spatial sd")
image.plot(proj.grid.mat$x, 
           proj.grid.mat$y,
           sd.g, add=TRUE)
plot(m_atn_rec, add=TRUE)


### --- Posterior q0.025 --- ###
plot(sps2, col="gray", main="Spatial q0.025")
image.plot(proj.grid.mat$x, 
           proj.grid.mat$y,
           quantile_0.025, add=TRUE)
plot(m_atn_rec, add=TRUE)

### --- Posterior q0.975 --- ###
plot(sps2, col="gray", main="Spatial q0.975")
image.plot(proj.grid.mat$x, 
           proj.grid.mat$y,
           quantile_0.975, add=TRUE)
plot(m_atn_rec, add=TRUE)
#dev.off()
```

```{r}
###########################################################################
###########################################################################
######################### --- Predicción --- ##############################
###########################################################################
###########################################################################
### --- Matrix which link the mesh with coordinates to predict--- ###
A.pred <- inla.spde.make.A(mesh, loc=proj.grid.mat$lattice$loc[!i.map, ]) #Parte espacial de la matriz de predicción
#Ahora hago una matriz de predición (la de antes era de estimación) de mi variable respuesta

### --- Stack to predict --- ###
stk.pred <- inla.stack(data=list(y=NA), #Ahora 
                       A=list(A.pred, 1), 
                       effects=list(spatial=1:spde$n.spde, #Hago una lista de lo que quiero dentro del modelo
                                    data.frame(beta0 = 1, 
                                               extract(predictors2, #Extraigo desde nuestros predictores los valores de la variable ambientales de este objeto espacial rojo y azul
                                                       proj.grid.mat$lattice$loc[!i.map, ]))), #Se podría haber hecho fuera pero así también funciona
                                                       tag='pred')

stk <- inla.stack(stk.est, stk.pred) #Junto las dos matrices de estimación y predicción


#### --- modelo --- ###
model.pred <- inla(formula.1, #Repito la fórmula de antes
                   data=inla.stack.data(stk), family="binomial", #Le paso la matriz de estimación conjunta
                   control.predictor=list(A=inla.stack.A(stk), compute=TRUE, link=1), #Quiero que me devuelva la predicción en una medida de 0 a 1 cuando pongo link=1
                   control.inla=list(strategy = "simplified.laplace"), # Strategy, hay 3: simplifylaplace, laplace y gaussiana. Es la forma que tiene inla de realizar las operaciones.
                   control.mode=list(theta=model.est$mode$theta, restart=TRUE), #Moda
                   control.results=list(return.marginals.random=FALSE, #Que no me de las marginales que ya las tengo
                                        return.marginals.predictor=FALSE), # Avoid some marginals
                   num.threads = 3, #Número de núcleos
                   verbose=FALSE)



saveRDS(model.pred, "C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera/GLM INLA/model_pred.rds")
model.pred<-readRDS("C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera/GLM INLA/model_pred.rds")
```

```{r}
####################################################
########### --- Plot predictions --- ###############
####################################################
### index for the prediction data
idx <- inla.stack.index(stk, 'pred')$data 

summary(model.pred$summary.fitted.val$mean[idx]) #Predicción de la presencia de la especie

### --- Organize probabilities into a matrix to visualize --- ###
prob.mean <- prob.sd <- prob.0.025<- prob.0.975 <- matrix(NA, proj.grid.mat$lattice$dims[1],
                                                          proj.grid.mat$lattice$dims[2])
prob.mean[!i.map] <- c(model.pred$summary.fitted.val$mean[idx])
prob.sd[!i.map] <- c(model.pred$summary.fitted.val$sd[idx])
prob.0.025[!i.map] <- c(model.pred$summary.fitted.val$`0.025quant`[idx])
prob.0.975[!i.map] <- c(model.pred$summary.fitted.val$`0.975quant`[idx])

# Si transformo model.pred$summary.fitted.val$`0.975quant`[idx]) en un raster puedo pintarlo con plot

```

```{r}
#### --- plot del efecto espacial --- ###

#pdf("predictive.pdf", width=10, height = 10)
### --- Spatial effect --- ###
# Son probabilidades de 0 a 1 de encontrar la especie. 

par(mfrow=c(2,2))
par(mar=c(2,3,3,6))

### --- posterior predictive mean --- ###
plot(sps2, col="gray", main="Predictiva mean")
image.plot(proj.grid.mat$x, 
           proj.grid.mat$y,
           prob.mean, add=TRUE, zlim=c(0,1)) #En ved de image.plot se puede usar ggplot

plot(m_atn_rec, add=TRUE)

# points(sdmdata[,9:10][which(sdmdata$pb==1),], col="red", pch=20)
# points(sdmdata[,9:10][which(sdmdata$pb==0),], col="blue", pch=20)

### --- posterior predictive sd --- ###
plot(sps2, col="gray", main="Predictiva sd")
image.plot(proj.grid.mat$x, 
           proj.grid.mat$y,
           prob.sd, add=TRUE)
plot(m_atn_rec, add=TRUE)
# points(sdmdata[,9:10][which(sdmdata$pb==1),], col="red", pch=20)
# points(sdmdata[,9:10][which(sdmdata$pb==0),], col="blue", pch=20)


### --- posterior predictive q0.025 --- ###
plot(sps2, col="gray", main="Predictiva q0.025")
image.plot(proj.grid.mat$x, 
           proj.grid.mat$y,
           prob.0.025, add=TRUE, zlim=c(0,1))
plot(m_atn_rec, add=TRUE)

### --- posterior predictive q0.975 --- ###
plot(sps2, col="gray", main="Predictiva q0.975")
image.plot(proj.grid.mat$x, 
           proj.grid.mat$y,
           prob.0.975, add=TRUE, zlim=c(0,1))
plot(m_atn_rec, add=TRUE)

#dev.off()
```

