---
title: "Código Modelos"
author: "Irene Extremera Serrano"
date: "6/12/2020"
output: html_document
---

````{r}
library(sp) #Tabajar con objetos de tipo espacial
library(rgdal) #Para que funcione sdmpredictors
library(carData)
library(car)
library(nlme)
library(gstat)
library(sf)
library(spData)
library(spdep)
library(lattice)
library(survival)
library(Formula)
library(ggplot2)
library(Hmisc)
library(raster) #Para poder trabajar con objetos tipo raster
library(leaflet)
library(GGally)
library(maptools)
library(corrplot)
library(rgeos)
library(maptools) #Cargar mapas
library(dismo) #Para poder trabajar con bioclim
library(sdmpredictors) #Para descargarme las variables ambientales
library(PresenceAbsence)
```


###########################################
##### --- Cargar la base de datos --- #####
###########################################

```{r}
# Descargo la base de datos de https://www.aquamaps.org/
# Tengo en la base de datos por defecto en el cabecero una descripción que hay que quitar.
data <- read.csv('Anchoas_Aqua.csv',TRUE,",")

# Miro las variables que tiene la base de datos y me quedo con las que me interesan
names(data)
data <- data[, c(3,4)]

# Me cercioro de que efectivamente me he quedado con las que necesito
names(data)

# Les cambio el nombre
colnames(data)<- c('Lat','Lon')

# Descargo el mapa del mundo
data(wrld_simpl) #Cargo el mapa del mundo
```

```{r}
# Pinto los datos para ver por dónde están las anchoas. Corto por Atlántico Norte y Mediterraneo.
plot(wrld_simpl, xlim= c(-25,40),ylim=c(30,65), axes=TRUE,col="light yellow")
points(data$Lon, data$Lat, col="orange", pch=20, cex=0.75)
points(data$Lon, data$Lat, col="red", cex=0.75)

# Identifico los puntos que no están en el Mediterraneo y en el norte de Europa que me podrían dar problemas para modelizar 
identify(data$Lon, data$Lat) 

#No parece que haya errores en los datos porque al pintarlos aparecen en las mismas zonas que en las que aparecen en el mapa de: https://www.gbif.org/species/2414031

# Los puntos de África voy a quitarlos porque van a ser difíciles de modelizar, por lo que me quedo solo con Europa.Lo mismo con los datos del Mar Muerto.
data <- data[c(-151, -152, -153, -160, -163, -164, -165, -166),]

# Vuelvo a hacer el plot para cerciorarme que se han eliminado correctamente.
plot(wrld_simpl, xlim= c(-25,40),ylim=c(30,65), axes=TRUE,col="light yellow")
points(data$Lon, data$Lat, col="orange", pch=20, cex=0.75)
points(data$Lon, data$Lat, col="red", cex=0.75)
```

```{r}
#Miro si hay duplicados
dups2 <- duplicated(data[, c("Lon","Lat")]) 

#Veo cuántos duplicados 
sum(dups2) 

#Verificar si son diferentes antes de eliminarlos.
data <- data[!dups2, ] 
```

```{r}
# Las variables explicativas que voy a usar son: slainidad, oxígeno disuelto, temperatura de la superficie, clorofila media (de la base de datos "Bio-ORACLE") y batimetría (de la base de datos MARSPEC).
# Me las descargo
bathy<- load_layers(c("MS_bathy_5m"))
ocean<- load_layers(c("BO2_chlomean_ss"))
ocean2<- load_layers(c("BO2_ppmean_ss","BO2_dissoxmean_ss","BO2_salinitymean_ss","BO2_tempmean_ss"))


# Uso la función resample para igualar el número de filas 
bathy=resample(bathy,ocean2)
ocean=resample(ocean,ocean2)

# Meto los predictores en una misma base de datos

predictors=stack(bathy,ocean,ocean2)

# Doy nombres a las variables explicativas
names(predictors) <- c("bathy","chlomean","ppmean","ox","sss","sst")

# Me quedo con los valores de los predictores de la zona en la que voy a trabajar
ext<-extent(-25,40,30,65)
predictors<-crop(predictors,ext)

# Me cercioro de que los predictores cogen el area que quiero
plot(predictors)

# Me guardo las variables en un raster para no tener que estar descargándolas
writeRaster(predictors, filename="predictors.tif", format="GTiff", overwrite=TRUE)

# Llamo a mis predictores
predictors<- raster("predictors.tif")

# Estandarizo las variables para que estén en la misma escala
predictors2 <- scale(predictors)
round(apply(values(predictors2), 2, summary), 4) 

par(mfrow=c(2,2))
plot(predictors2$predictors)
```

```{r}
bathy<- load_layers(c("MS_bathy_5m"))
chlomean<- load_layers(c("BO2_chlomean_ss"))
ppmean<- load_layers(c("BO2_ppmean_ss"))
tempmean <- load_layers(c("BO2_tempmean_ss"))
odismean<- load_layers(c("BO2_dissoxmean_ss"))
salinity <- load_layers(c("BO2_salinitymean_ss"))
bathy=resample(bathy,salinity)
chlomean=resample(chlomean,salinity)

ext<-extent(-25,40,30,65)
bathy<-crop(bathy,ext)
chlomean<-crop(chlomean,ext)
ppmean<-crop(ppmean,ext)
tempmean<-crop(tempmean,ext)
odismean<-crop(odismean,ext)
salinity<-crop(salinity,ext)

writeRaster(bathy, filename="bathy.tif", format="GTiff", overwrite=TRUE)
writeRaster(chlomean, filename="chlomean.tif", format="GTiff", overwrite=TRUE)
writeRaster(ppmean, filename="ppmean.tif", format="GTiff", overwrite=TRUE)
writeRaster(odismean, filename="odismean.tif", format="GTiff", overwrite=TRUE)
writeRaster(salinity, filename="salinity.tif", format="GTiff", overwrite=TRUE)
writeRaster(tempmean, filename="tempmean.tif", format="GTiff", overwrite=TRUE)

files<-(list.files("C:/Users/Irene/Source/Repositorios/TFM-Irene-Extremera", full.names=T, pattern=".tif"))#change directory
predictors <- stack(files)
names(predictors) <- c("bathy","chlomean","ppmean","odismean","salinity","tempmean")
plot(predictors)

# Miro a ver si hay NAs
values(predictors) #Los hay 

# Escalo los valores
predictors2 <- scale(predictors)
round(apply(values(predictors2), 2, summary), 4) 
```

#############################################################
##### --- Presencias, Pseudoausencias & Otras cosas --- #####
#############################################################

```{r}
# Presencias: 
# Extraigo las coordenadas y les doy nombre
coords=cbind(data$Lon, data$Lat) 
colnames(coords)<-c("x","y") 

# La función extract permite extraer los valores de la variable ambiental de las coordenadas donde están las presencias
presvals <- extract(predictors2, coords) 

# Me cercioro de que todo está correcto
head(presvals)
```

```{r}
# Pseudoausencias
# Pongo una semilla para que me aparezcan los puntos en el mismo sitio
# Genero 1000 pseudoausencias en la zona que me interesa
set.seed(141592) 
backgr <- randomPoints(predictors2, 1000) 

#Lo transformo en data.frame para poder trabajar con él
backgr <-as.data.frame(backgr) 
head(backgr)
```

```{r}
# Pinto las pseudoausencias con el fin de ver que efectivamente se han creado
plot(wrld_simpl, xlim=c(-70,-30), ylim=c(-55,-20), axes=TRUE,col="light yellow")
points(data$Lon, data$Lat, col="orange", pch=20, cex=0.75)
points(backgr, col="black", pch=20, cex=0.75)
```


```{r}
# Extraigo valores de las variables ambientales de las pseudoausencias
absvals <- extract(predictors2, backgr) 

# Me cercioro de que todo está bien
head(absvals)
```

```{r}
#Hago La Base de Datos DEFINITIVA
# Genero un único vector de coordenadas
coords<-as.data.frame(rbind(coords,backgr)) 

# Genero un vector con tantas presencias (1) y ausencias (0) haya
pb <- c(rep(1, nrow(presvals)), rep(0, nrow(absvals)))

# Junto los datos de las variables ambientales de presencia y pseudoausencia con los 0 y 1.
sdmdata <- data.frame(cbind(pb, rbind(presvals, absvals), coords)) 
head(sdmdata)
```

```{r}
#Miro si hay NAs y los quito si son pocos, pero si son muchos hago una imputación de la media de los datos que están cercanos.
summary(sdmdata) 
to.remove <- which(!complete.cases(sdmdata))
sdmdata <- sdmdata[-to.remove,]

# Vuelvo a hacer el summary para cerciorarme de que ya no tengo NAs
summary(sdmdata)

# Guardo la base de datos para usarla posteriormente
save(sdmdata,"sdmdata.csv")
```

###############################
##### --- Descriptiva --- #####
###############################


##################################
##### --- Ajuste modelos --- #####
##################################

# BIOCLIM

```{r}
# Delimito la extensión geográfica
max.lat <- ceiling(max(data$Lat))
min.lat <- floor(min(data$Lat))
max.lon <- ceiling(max(data$Lon))
min.lon <- floor(min(data$Lon))
geographic.extent <- extent(x = c(min.lon, max.lon, min.lat, max.lat))

# Extraigo los predictores para esa zona 
bioclim.data <- crop(x = predictors2, y = geographic.extent)

# Build species distribution model
coords <- as.matrix(cbind(data$Lon,data$Lat))
bc.model <- bioclim(x = bioclim.data, p = coords)
plot(bc.model) #¿El modelo muestra los valores de media de cloro y de calcio? ¿Son los valores estimados?
summary(bc.model) 


# Predict presence from model
predict.presence <- dismo::predict(object = bc.model, 
                                   x = bioclim.data, 
                                   ext = geographic.extent)
plot(predict.presence)
```

```{r}
# Calibración del modelo: https://juvelas.github.io/Clases/Modelos_Validaciones.html
# Asigno a cada grupo de coordenadas a un grupo de hasta 5
group <- kfold(coords, 5)

# Distingo estos grupos a su vez en dos, uno de entrenamiento y otro de validación
pres_train <- coords[group != 1, ] #Las que no sean 1
pres_test <- coords[group == 1, ] #Las que sean 1

# Vuelvo a hacer el modelo
bc <- bioclim(predictors2, pres_train)
plot(bc) #Está prácticamente igual solo que le faltan algunos puntos

# Generación de ausencias
backg <- randomPoints(predictors2, n=855, ext= geographic.extent) #Genero 650 puntos aleatorios que sean 0 dentro de ext

colnames(backg) = c('Longitude', 'Latitude')
group <- kfold(backg, 5) #Hago 5 grupos de esos puntos
backg_train <- backg[group != 1, ]
backg_test <- backg[group == 1, ]

# Pinto esos valores de ausencia y presencia 
plot(predictors2[[1]])
points(backg_train, pch='-', cex=1, col='yellow')
points(backg_test, pch='-',  cex=1, col='black')
points(pres_train, pch= '+', col='green')
points(pres_test, pch='+', col='blue')

# Validación del modelo
eval.modesta <- evaluate(pres_test, backg_test, bc, predictors2)
eval.modesta #¿Cçomo interpreto los outputs?

# AUC 0.612 predice ligeramente mejor que un proceso random (Es el area bajo la curva roc)
# COR 0.1867
# TPR+TNR ¿Será el porcentaje de las veces que esto es correcto?
# Kappa ¿cómo lo obtengo? No entiendo muy bien lo que mide
# ¿Se puede hacer BIOCLIM en bayesiano?


```

```{r}
#  Para predecir se usa el criterio de umbral del “minimum presence training” ¿Cómo interpreto esto?
tr <- threshold(eval.modesta, 'spec_sens')
tr #Coge TPR+TPN

pred.bioc.v3 <- predict(predictors2, bc, ext= geographic.extent, progress='')
pred.bioc.v3

par(mfrow=c(1,2))
plot(pred.bioc.v3, main='Bioclim, valores crudos')
plot(pred.bioc.v3 > tr, main='presencia/ausencia') 
points(pres_train, pch='+')
```

```{r}
# Kappa
```

Bayesiano: ¿?

# MAXENT
Frecuentista: Video de youtube
Bayesiano: ¿?

```{r}
# download maxent.jar 3.3.3k, and place the file in the desired folder
utils::download.file(url="https://raw.githubusercontent.com/mrmaxent/Maxent/master/ArchivedReleases/3.3.3k/maxent.jar",
                     destfile=paste0(system.file("java", package="dismo"),"/maxent.jar"),
                     mode="wb") ## wb for binary file, otherwise maxent.jar can not execute

# We create a buffer around our occurrence locations and define this as our study region, which will allow us to avoid sampling from a broad background.
# We establish a four-decimal-degree buffer around the occurrence points. 
# To make sure that our buffer encompasses the appropriate area, we plot the occurrence points, the first environmental layer, and the buffer polygon.

```

# GLM
Frecuentista: ¿?
Bayesiano: INLA


# RF
Frecuentista: Clase 1 María
Bayesiano: ¿?

```{r}
# No tiene en cuenta el error.

library(randomForest)
attach(data)

coords<- cbind(data$Lon,data$Lat)
colnames(coords)<- c('x','y')

backgr <- randomPoints(predictors2, 855)

presvals <- extract(predictors2, coords)  #Hay muchos NAs ¿Qué pasa?
absvals <- extract(predictors2, backgr)

pb <- c(rep(1, nrow(presvals)), rep(0, nrow(absvals))) #1 donde hay presencia y 0 donde hay ausencias


# INTENTO
sdmdata <- data.frame(cbind(pb, rbind(presvals, absvals), coords)) 

model <- pb ~ calcite+nitrate+salinity
rf3 <- randomForest(model, sdmdata);rf3
varImpPlot(rf3)

#Now prediction
prf= predict(predictors2, rf3,type="response") #Puedo hacer la predicción también

#tiff("Figure_RF.tiff", width = 3700, height = 1800, res = 300)
par(mfrow=c(1,1))
plot(prf)
plot(wrld_simpl, axes=TRUE,add=T,col="grey")
points(sdmdata$x,sdmdata$y, col=sdmdata$pb+1,pch=20, cex=0.75)
#dev.off()

```


```{r}
# Validación Cruzada
model <- pb ~ calcite+nitrate+salinity
mrf1 <- randomForest(model, traindata);mrf1

erf <- evaluate(testdata[testdata==1,], testdata[testdata==0,],mrf1);erf #Puedo hacer un cross validation
```

# BRT
Frecuentista: Clase 1 María
Bayesiano: ¿?

```{r}
library(gbm)
brt1 = gbm.step(data=sdmdata, gbm.x = c(2,3,4,5,6,7,8,9), gbm.y = 1, tree.complexity=1, family = "bernoulli",  learning.rate = 0.01)
devexpl=((brt1$self.statistics$null-brt1$self.statistics$resid)/brt1$self.statistics$null)*100
devexpl
summary(brt1)

#Try without variables with low relevance (< 4% relative variance expaliend)
brt2 = gbm.step(data=sdmdata, gbm.x = c(3,4,5,8), gbm.y = 1, tree.complexity=1, family = "bernoulli",  learning.rate = 0.01)
#Los números es la posición de la variable dentro de la base de datos
# gbm.step permite calcular brt con un número de decimales. Learning.rate = cuánto va aprendiendo para mejorar la inclusión de variables
# Va indicando la proporción de deviance explicada del conjunto de variables 

devexpl=((brt2$self.statistics$null-brt2$self.statistics$resid)/brt2$self.statistics$null)*100
devexpl #% de deviance explicada por el modelo
summary(brt2) #% de deviance explicada por cada variable

#Try without variables with low relevance (< 4% relative variance expaliend)
brt3 = gbm.step(data=sdmdata, gbm.x = c(2,4,8), gbm.y = 1, tree.complexity=1, family = "bernoulli",  learning.rate = 0.01)
devexpl=((brt3$self.statistics$null-brt3$self.statistics$resid)/brt3$self.statistics$null)*100
devexpl
summary(brt3) #Se puede observar en el diagrama 

# Se está usando este tipo de modelos para hacer la selección de variables 

#Plot the functional responses 
gbm.plot(brt3, n.plots=3, write.title=FALSE, plot.layout=c(1,3), common.scale=F) #respuesta funcional de la variable con respecto a la variable respuesta

#Now prediction
pbrt= predict(predictors2, brt3,type="response", n.trees=brt3$n.trees, shrinkage= 0.01, distribution="bernoulli")
# Con ese modelo se puede aplicar predict

#tiff("Figure_BRT.tiff", width = 3700, height = 1800, res = 300)
par(mfrow=c(1,1))
plot(pbrt)
plot(wrld_simpl, axes=TRUE,add=T,col="grey") #Sale un mapa similar al glm pero este muestra mas movimiento, imagen mas heterogeneo
points(sdmdata$x,sdmdata$y, col=sdmdata$pb+1,pch=20, cex=0.75)
#dev.off()

```

```{r}
# Validación cruzada
mbrt= gbm.step(data=traindata, gbm.x = c(2,4,8), gbm.y = 1, tree.complexity=1, family = "bernoulli",  learning.rate = 0.01)

ebrt <- evaluate(testdata[testdata==1,], testdata[testdata==0,],mbrt,n.trees=mbrt$n.trees);ebrt

```














