---
title: "Código Modelos"
author: "Irene Extremera Serrano"
date: "6/12/2020"
output: html_document
---

````{r}
library(sp) #Tabajar con objetos de tipo espacial
library(rgdal)
library(raster) #Para poder trabajar con objetos tipo raster
library(rgeos)
library(maptools) #Cargar mapas
library(dismo) #Para poder trabajar con bioclim
```


###########################################
##### --- Cargar la base de datos --- #####
###########################################

```{r}
# Descargar base de datos de https://www.aquamaps.org/
data <- read.csv('Anchoas_Aqua.csv',TRUE,",") #Tengo en la base de datos por defecto en el cabecero una descripción que hay que quitar.
names(data)
colnames(data)<- c('Género','Especie','Lat','Lon','C.Square','Profundidad (metros)','Tª sup agua','Tª prof agua','Salinidad sup (psu)','Salinidad prof (psu)','Producción Primaria (mgC.m.3.day1)','Concentración de hielo en mar (0.1 fracción)','Oxígeno disuelto (mmol.m.3)', 'Distancia a la costa (km)')

# Descargo el mapa del mundo
data(wrld_simpl) #Cargo el mapa del mundo
```

```{r}
# Pinto los datos
plot(wrld_simpl, xlim= c(-25,40),ylim=c(30,70), axes=TRUE,col="light yellow")
points(data$Lon, data$Lat, col="orange", pch=20, cex=0.75)
points(data$Lon, data$Lat, col="red", cex=0.75)

identify(data$Lon, data$Lat) # Identifico los puntos que no están en el Mediterraneo y en el norte de Europa

#No parece que haya errores en los datos porque al pintarlos aparecen en las mismas zonas que en las que aparecen en el mapa de: https://www.gbif.org/species/2414031

# Los puntos de África voy a quitarlos porque van a ser difíciles de modelizar, por lo que me quedo solo con Europa.
data <- data[c(-151, -152, -153, -160, -163, -164, -165, -166),]

plot(wrld_simpl, xlim= c(-25,40),ylim=c(30,70), axes=TRUE,col="light yellow")
points(data$Lon, data$Lat, col="orange", pch=20, cex=0.75)
points(data$Lon, data$Lat, col="red", cex=0.75)
```

```{r}
#Miro si hay duplicados
dups2 <- duplicated(data[, c("Especie","Lon","Lat")]) #Compruebo que no hay duplicados en esas columnas
sum(dups2) #Veo cuántos duplicados son: 258
data <- data[!dups2, ] #Verificar si son diferentes antes de eliminarlos.
```

```{r}
# Por ahora voy a usar las mismas variables que la otra vez. En caso de querer descargármelas.
# list_layers(c("Bio-ORACLE","MARSPEC"))$layer_code #Dos bases de datos ecológicos marinos: MARSPEC topografía marina y BIORACLE temperatura, salinidad...

files <-(list.files("D:/Desktop/Remember/Estudios/Educación Formal/Máster/Máster Valencia/Bioestadística/Curso 2/Especialización/8 Distribución de Especies/Clase 1/Practice1/predictors", full.names=T, pattern=".tif"))
predictors <- stack(files)#bioclimatic variables  #Si miro este objeto me dicen la dimensión (extensión del raster),extent (latitud y longitud máxima y mínima) resolución (0.08 es una buena resolución), sistema de referencia (DatumWGS84 indica coordenadas geográficas)
names(predictors) <- c("calcite","chlomean","nitrate","ph","phos","salinity","silicate","sstmean")

# Empiezo a tratar los datos
## Me quedo con los valores de los predictores de la zona en la que voy a trabajar
ext<-extent(-25,40,15,80)
predictors<-crop(predictors,ext)
plot(predictors)

# Estandarizo las variables
predictors2 <- scale(predictors)
round(apply(values(predictors2), 2, summary), 4)
```


###############################
##### --- Descriptiva --- #####
###############################


##################################
##### --- Ajuste modelos --- #####
##################################

# BIOCLIM

```{r}
# Delimito la extensión geográfica
max.lat <- ceiling(max(data$Lat))
min.lat <- floor(min(data$Lat))
max.lon <- ceiling(max(data$Lon))
min.lon <- floor(min(data$Lon))
geographic.extent <- extent(x = c(min.lon, max.lon, min.lat, max.lat))

# Extraigo los predictores para esa zona 
bioclim.data <- crop(x = predictors2, y = geographic.extent)

# Build species distribution model
coords <- as.matrix(cbind(data$Lon,data$Lat))
bc.model <- bioclim(x = bioclim.data, p = coords)
plot(bc.model) #¿El modelo muestra los valores de media de cloro y de calcio? ¿Son los valores estimados?
summary(bc.model) 


# Predict presence from model
predict.presence <- dismo::predict(object = bc.model, 
                                   x = bioclim.data, 
                                   ext = geographic.extent)
plot(predict.presence)
```

```{r}
# Calibración del modelo: https://juvelas.github.io/Clases/Modelos_Validaciones.html
# Asigno a cada grupo de coordenadas a un grupo de hasta 5
group <- kfold(coords, 5)

# Distingo estos grupos a su vez en dos, uno de entrenamiento y otro de validación
pres_train <- coords[group != 1, ] #Las que no sean 1
pres_test <- coords[group == 1, ] #Las que sean 1

# Vuelvo a hacer el modelo
bc <- bioclim(predictors2, pres_train)
plot(bc) #Está prácticamente igual solo que le faltan algunos puntos

# Generación de ausencias
backg <- randomPoints(predictors2, n=855, ext= geographic.extent) #Genero 650 puntos aleatorios que sean 0 dentro de ext

colnames(backg) = c('Longitude', 'Latitude')
group <- kfold(backg, 5) #Hago 5 grupos de esos puntos
backg_train <- backg[group != 1, ]
backg_test <- backg[group == 1, ]

# Pinto esos valores de ausencia y presencia 
plot(predictors2[[1]])
points(backg_train, pch='-', cex=1, col='yellow')
points(backg_test, pch='-',  cex=1, col='black')
points(pres_train, pch= '+', col='green')
points(pres_test, pch='+', col='blue')

# Validación del modelo
eval.modesta <- evaluate(pres_test, backg_test, bc, predictors2)
eval.modesta #¿Cçomo interpreto los outputs?

# AUC 0.612 predice ligeramente mejor que un proceso random (Es el area bajo la curva roc)
# COR 0.1867
# TPR+TNR ¿Será el porcentaje de las veces que esto es correcto?
# Kappa ¿cómo lo obtengo? No entiendo muy bien lo que mide
# ¿Se puede hacer BIOCLIM en bayesiano?


```

```{r}
#  Para predecir se usa el criterio de umbral del “minimum presence training” ¿Cómo interpreto esto?
tr <- threshold(eval.modesta, 'spec_sens')
tr #Coge TPR+TPN

pred.bioc.v3 <- predict(predictors2, bc, ext= geographic.extent, progress='')
pred.bioc.v3

par(mfrow=c(1,2))
plot(pred.bioc.v3, main='Bioclim, valores crudos')
plot(pred.bioc.v3 > tr, main='presencia/ausencia') 
points(pres_train, pch='+')
```

```{r}
# Kappa
```

Bayesiano: ¿?

# MAXENT
Frecuentista: Video de youtube
Bayesiano: ¿?

```{r}
# download maxent.jar 3.3.3k, and place the file in the desired folder
utils::download.file(url="https://raw.githubusercontent.com/mrmaxent/Maxent/master/ArchivedReleases/3.3.3k/maxent.jar",
                     destfile=paste0(system.file("java", package="dismo"),"/maxent.jar"),
                     mode="wb") ## wb for binary file, otherwise maxent.jar can not execute

# We create a buffer around our occurrence locations and define this as our study region, which will allow us to avoid sampling from a broad background.
# We establish a four-decimal-degree buffer around the occurrence points. 
# To make sure that our buffer encompasses the appropriate area, we plot the occurrence points, the first environmental layer, and the buffer polygon.

```

# GLM
Frecuentista: ¿?
Bayesiano: INLA


# RF
Frecuentista: Clase 1 María
Bayesiano: ¿?

```{r}
# No tiene en cuenta el error.

library(randomForest)
attach(data)

coords<- cbind(data$Lon,data$Lat)
colnames(coords)<- c('x','y')

backgr <- randomPoints(predictors2, 855)

presvals <- extract(predictors2, coords)  #Hay muchos NAs ¿Qué pasa?
absvals <- extract(predictors2, backgr)

pb <- c(rep(1, nrow(presvals)), rep(0, nrow(absvals))) #1 donde hay presencia y 0 donde hay ausencias


# INTENTO
sdmdata <- data.frame(cbind(pb, rbind(presvals, absvals), coords)) 

model <- pb ~ calcite+nitrate+salinity
rf3 <- randomForest(model, sdmdata);rf3
varImpPlot(rf3)

#Now prediction
prf= predict(predictors2, rf3,type="response") #Puedo hacer la predicción también

#tiff("Figure_RF.tiff", width = 3700, height = 1800, res = 300)
par(mfrow=c(1,1))
plot(prf)
plot(wrld_simpl, axes=TRUE,add=T,col="grey")
points(sdmdata$x,sdmdata$y, col=sdmdata$pb+1,pch=20, cex=0.75)
#dev.off()

```


```{r}
# Validación Cruzada
model <- pb ~ calcite+nitrate+salinity
mrf1 <- randomForest(model, traindata);mrf1

erf <- evaluate(testdata[testdata==1,], testdata[testdata==0,],mrf1);erf #Puedo hacer un cross validation
```

# BRT
Frecuentista: Clase 1 María
Bayesiano: ¿?

```{r}
library(gbm)
brt1 = gbm.step(data=sdmdata, gbm.x = c(2,3,4,5,6,7,8,9), gbm.y = 1, tree.complexity=1, family = "bernoulli",  learning.rate = 0.01)
devexpl=((brt1$self.statistics$null-brt1$self.statistics$resid)/brt1$self.statistics$null)*100
devexpl
summary(brt1)

#Try without variables with low relevance (< 4% relative variance expaliend)
brt2 = gbm.step(data=sdmdata, gbm.x = c(3,4,5,8), gbm.y = 1, tree.complexity=1, family = "bernoulli",  learning.rate = 0.01)
#Los números es la posición de la variable dentro de la base de datos
# gbm.step permite calcular brt con un número de decimales. Learning.rate = cuánto va aprendiendo para mejorar la inclusión de variables
# Va indicando la proporción de deviance explicada del conjunto de variables 

devexpl=((brt2$self.statistics$null-brt2$self.statistics$resid)/brt2$self.statistics$null)*100
devexpl #% de deviance explicada por el modelo
summary(brt2) #% de deviance explicada por cada variable

#Try without variables with low relevance (< 4% relative variance expaliend)
brt3 = gbm.step(data=sdmdata, gbm.x = c(2,4,8), gbm.y = 1, tree.complexity=1, family = "bernoulli",  learning.rate = 0.01)
devexpl=((brt3$self.statistics$null-brt3$self.statistics$resid)/brt3$self.statistics$null)*100
devexpl
summary(brt3) #Se puede observar en el diagrama 

# Se está usando este tipo de modelos para hacer la selección de variables 

#Plot the functional responses 
gbm.plot(brt3, n.plots=3, write.title=FALSE, plot.layout=c(1,3), common.scale=F) #respuesta funcional de la variable con respecto a la variable respuesta

#Now prediction
pbrt= predict(predictors2, brt3,type="response", n.trees=brt3$n.trees, shrinkage= 0.01, distribution="bernoulli")
# Con ese modelo se puede aplicar predict

#tiff("Figure_BRT.tiff", width = 3700, height = 1800, res = 300)
par(mfrow=c(1,1))
plot(pbrt)
plot(wrld_simpl, axes=TRUE,add=T,col="grey") #Sale un mapa similar al glm pero este muestra mas movimiento, imagen mas heterogeneo
points(sdmdata$x,sdmdata$y, col=sdmdata$pb+1,pch=20, cex=0.75)
#dev.off()

```

```{r}
# Validación cruzada
mbrt= gbm.step(data=traindata, gbm.x = c(2,4,8), gbm.y = 1, tree.complexity=1, family = "bernoulli",  learning.rate = 0.01)

ebrt <- evaluate(testdata[testdata==1,], testdata[testdata==0,],mbrt,n.trees=mbrt$n.trees);ebrt

```














